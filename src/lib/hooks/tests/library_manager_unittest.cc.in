// Copyright (C) 2013  Internet Systems Consortium, Inc. ("ISC")
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
// OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.

#include <hooks/callout_handle.h>
#include <hooks/callout_manager.h>
#include <hooks/library_manager.h>
#include <hooks/server_hooks.h>

#include <gtest/gtest.h>

#include <algorithm>
#include <string>
#include <vector>

#include <iostream>

using namespace isc;
using namespace isc::hooks;
using namespace std;

/// @brief Library manager test class

class LibraryManagerTest : public ::testing::Test {
public:
    /// @brief Constructor
    ///
    /// Sets up a collection of three LibraryHandle objects to use in the test.
    LibraryManagerTest() {

        // Set up the server hooks.  There is sone singleton for all tests,
        // so reset it and explicitly set up the hooks for the test.
        ServerHooks& hooks = ServerHooks::getServerHooks();
        hooks.reset();
        lm_one_index_ = hooks.registerHook("lm_one");
        lm_two_index_ = hooks.registerHook("lm_two");
        lm_three_index_ = hooks.registerHook("lm_three");

        // Set up the callout manager with these hooks.  Assume a maximum of
        // four libraries.
        callout_manager_.reset(new CalloutManager(1));

        // Set up the callout handle.
        callout_handle_.reset(new CalloutHandle(callout_manager_));
    }

    /// Hook indexes.  These are somewhat ubiquitous, so are made public for
    /// ease of reference instead of being accessible by a function.
    int lm_one_index_;
    int lm_two_index_;
    int lm_three_index_;

    /// Callout handle used in calls
    boost::shared_ptr<CalloutHandle> callout_handle_;

    /// Callout manager used for the test
    boost::shared_ptr<CalloutManager> callout_manager_;
};


/// @brief Library manager class
///
/// This is an instance of the LibraryManager class but with the protected
/// methods made public for test purposes.

class PublicLibraryManager : public isc::hooks::LibraryManager {
public:
    /// @brief Constructor
    ///
    /// Stores the library name.  The actual loading is done in loadLibrary().
    ///
    /// @param name Name of the library to load.  This should be an absolute
    ///        path name.
    /// @param index Index of this library.  For all these tests, it will be
    ///        zero, as we are only using one library.
    /// @param manager CalloutManager object
    PublicLibraryManager(const std::string& name, int index,
                         const boost::shared_ptr<CalloutManager>& manager)
        : LibraryManager(name, index, manager)
    {}

    /// @brief Destructor
    ///
    /// Ensures that the library is closed after the test.
    ~PublicLibraryManager() {
        static_cast<void>(closeLibrary());
    }

    /// Public methods that call protected methods on the superclass.
    using LibraryManager::openLibrary;
    using LibraryManager::closeLibrary;
    using LibraryManager::checkVersion;
    using LibraryManager::registerStandardCallouts;
    using LibraryManager::runLoad;
};

// Names of the libraries used in these tests.  These libraries are built using
// libtool, so we need to look in the hidden ".libs" directory to locate the
// .so file.  Note that we access the .so file - libtool creates this as a
// like to the real shared library.
static const char* BASIC_CALLOUT_LIBRARY = "@abs_builddir@/.libs/libbcl.so";
static const char* INCORRECT_VERSION_LIBRARY = "@abs_builddir@/.libs/libivl.so";
static const char* LOAD_CALLOUT_LIBRARY = "@abs_builddir@/.libs/liblcl.so";
static const char* LOAD_ERROR_CALLOUT_LIBRARY =
    "@abs_builddir@/.libs/liblecl.so";
static const char* NOT_PRESENT_LIBRARY = "@abs_builddir@/.libs/libnothere.so";
static const char* NO_VERSION_LIBRARY = "@abs_builddir@/.libs/libnvl.so";


namespace {

// Tests that OpenLibrary reports an error for an unknown library.

TEST_F(LibraryManagerTest, NonExistentLibrary) {
    PublicLibraryManager lib_manager(std::string(NOT_PRESENT_LIBRARY),
                                     0, callout_manager_);
    EXPECT_FALSE(lib_manager.openLibrary());
}

// Tests that the openLibrary() and closeLibrary() methods work.

TEST_F(LibraryManagerTest, OpenClose) {
    PublicLibraryManager lib_manager(std::string(BASIC_CALLOUT_LIBRARY),
                                     0, callout_manager_);

    // Open and close the library
    EXPECT_TRUE(lib_manager.openLibrary());
    EXPECT_TRUE(lib_manager.closeLibrary());

    // Check that a second close does not report an error.
    EXPECT_TRUE(lib_manager.closeLibrary());
}

// Check that the code handles the case of a library with no version function.

TEST_F(LibraryManagerTest, NoVersionFunction) {
    PublicLibraryManager lib_manager(std::string(NO_VERSION_LIBRARY),
                                     0, callout_manager_);
    // Open should succeed.
    EXPECT_TRUE(lib_manager.openLibrary());

    // Version check should fail.
    EXPECT_FALSE(lib_manager.checkVersion());

    // Tidy up.
    EXPECT_TRUE(lib_manager.closeLibrary());
}

// Check that the code handles the case of a library with a version function
// that returns an incorrect version number.

TEST_F(LibraryManagerTest, IncorrectVersionReturned) {
    PublicLibraryManager lib_manager(std::string(INCORRECT_VERSION_LIBRARY),
                                     0, callout_manager_);
    // Open should succeed.
    EXPECT_TRUE(lib_manager.openLibrary());

    // Version check should fail.
    EXPECT_FALSE(lib_manager.checkVersion());

    // Tidy up.
    EXPECT_TRUE(lib_manager.closeLibrary());
}

// Tests that checkVersion() function succeeds in the case of a library with a
// version function that returns the correct version number.

TEST_F(LibraryManagerTest, CorrectVersionReturned) {
    PublicLibraryManager lib_manager(std::string(BASIC_CALLOUT_LIBRARY),
                                     0, callout_manager_);
    // Open should succeed.
    EXPECT_TRUE(lib_manager.openLibrary());

    // Version check should succeed.
    EXPECT_TRUE(lib_manager.checkVersion());

    // Tidy up.
    EXPECT_TRUE(lib_manager.closeLibrary());
}

// Checks the registration of standard callouts.

TEST_F(LibraryManagerTest, RegisterStandardCallouts) {

    // Load the only library, specifying the index of 0 as it's the only
    // library.  This should load all callouts.
    PublicLibraryManager lib_manager(std::string(BASIC_CALLOUT_LIBRARY),
                               0, callout_manager_);
    EXPECT_TRUE(lib_manager.openLibrary());

    // Check the version of the library.
    EXPECT_TRUE(lib_manager.checkVersion());

    // Load the standard callouts
    EXPECT_NO_THROW(lib_manager.registerStandardCallouts());

    int result = 0;

    // Now execute the callouts in the order expected.  context_create
    // always comes first.  This sets the context value to 10.
    callout_manager_->callCallouts(ServerHooks::CONTEXT_CREATE,
                                   *callout_handle_);

    // First callout adds 5 to the context value.
    callout_handle_->setArgument("data_1", static_cast<int>(5));
    callout_manager_->callCallouts(lm_one_index_, *callout_handle_);
    callout_handle_->getArgument("result", result);
    EXPECT_EQ(15, result);

    // Second callout multiples the running total by 7
    callout_handle_->setArgument("data_2", static_cast<int>(7));
    callout_manager_->callCallouts(lm_two_index_, *callout_handle_);
    callout_handle_->getArgument("result", result);
    EXPECT_EQ(105, result);

    // Third callout subtracts 17 from the running total.
    callout_handle_->setArgument("data_3", static_cast<int>(17));
    callout_manager_->callCallouts(lm_three_index_, *callout_handle_);
    callout_handle_->getArgument("result", result);
    EXPECT_EQ(88, result);

    // Explicitly clear the callout_handle_ so that we can delete the library.
    // This is the only object to contain memory allocated by it.
    callout_handle_.reset();

    // Tidy up
    EXPECT_TRUE(lib_manager.closeLibrary());
}

// Test that the "load" function is called correctly.

TEST_F(LibraryManagerTest, CheckLoadCalled) {

    // Load the only library, specifying the index of 0 as it's the only
    // library.  This should load all callouts.
    PublicLibraryManager lib_manager(std::string(LOAD_CALLOUT_LIBRARY),
                                     0, callout_manager_);
    EXPECT_TRUE(lib_manager.openLibrary());

    // Check the version of the library.
    EXPECT_TRUE(lib_manager.checkVersion());

    // Load the standard callouts
    EXPECT_NO_THROW(lib_manager.registerStandardCallouts());

    int result = 0;

    // Check that only context_create and lm_one have callouts registered.
    EXPECT_TRUE(callout_manager_->calloutsPresent(
                ServerHooks::CONTEXT_CREATE));
    EXPECT_TRUE(callout_manager_->calloutsPresent(lm_one_index_));
    EXPECT_FALSE(callout_manager_->calloutsPresent(lm_two_index_));
    EXPECT_FALSE(callout_manager_->calloutsPresent(lm_three_index_));
    EXPECT_FALSE(callout_manager_->calloutsPresent(
                 ServerHooks::CONTEXT_DESTROY));

    // Call the runLoad() method to run the load() function.
    EXPECT_TRUE(lib_manager.runLoad());
    EXPECT_TRUE(callout_manager_->calloutsPresent(
                ServerHooks::CONTEXT_CREATE));
    EXPECT_TRUE(callout_manager_->calloutsPresent(lm_one_index_));
    EXPECT_TRUE(callout_manager_->calloutsPresent(lm_two_index_));
    EXPECT_TRUE(callout_manager_->calloutsPresent(lm_three_index_));
    EXPECT_FALSE(callout_manager_->calloutsPresent(
                 ServerHooks::CONTEXT_DESTROY));

    // Now execute the callouts in the order expected.
    // only the first callout should be executed and the
    // always comes first.  This sets the context value to 10.
    callout_manager_->callCallouts(ServerHooks::CONTEXT_CREATE,
                                   *callout_handle_);

    // First callout multiplies the passed data by 5.
    callout_handle_->setArgument("data_1", static_cast<int>(5));
    callout_manager_->callCallouts(lm_one_index_, *callout_handle_);
    callout_handle_->getArgument("result", result);
    EXPECT_EQ(25, result);

    // Second callout adds 7 to the stored data.
    callout_handle_->setArgument("data_2", static_cast<int>(7));
    callout_manager_->callCallouts(lm_two_index_, *callout_handle_);
    callout_handle_->getArgument("result", result);
    EXPECT_EQ(32, result);

    // Third callout multiplies the running total by 10
    callout_handle_->setArgument("data_3", static_cast<int>(10));
    callout_manager_->callCallouts(lm_three_index_, *callout_handle_);
    callout_handle_->getArgument("result", result);
    EXPECT_EQ(320, result);

    // Explicitly clear the callout_handle_ so that we can delete the library.
    // This is the only object to contain memory allocated by it.
    callout_handle_.reset();

    // Tidy up
    EXPECT_TRUE(lib_manager.closeLibrary());
}

// Check handling of a "load" function that returns an error.

TEST_F(LibraryManagerTest, CheckLoadError) {

    // Load the only library, specifying the index of 0 as it's the only
    // library.  This should load all callouts.
    PublicLibraryManager lib_manager(std::string(LOAD_ERROR_CALLOUT_LIBRARY),
                                     0, callout_manager_);
    EXPECT_TRUE(lib_manager.openLibrary());

    // Check that we catch a load error
    EXPECT_FALSE(lib_manager.runLoad());

    // Explicitly clear the callout_handle_ so that we can delete the library.
    // This is the only object to contain memory allocated by it.
    callout_handle_.reset();

    // Tidy up
    EXPECT_TRUE(lib_manager.closeLibrary());
}

} // Anonymous namespace
