#!@PYTHON@

# Copyright (C) 2010  Internet Systems Consortium.
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SYSTEMS CONSORTIUM
# DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
# INTERNET SYSTEMS CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
# FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
# WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
This file implements user management program. The user name and
its password is appended to csv file.
'''
from bind10_config import SYSCONFPATH
import random
from hashlib import sha1
import csv
import getpass
from optparse import OptionParser, OptionValueError
import os
import sys; sys.path.append ('@@PYTHONPATH@@')
import isc.util.process

isc.util.process.rename()

VERSION_STRING = "b10-cmdctl-usermgr @PACKAGE_VERSION@"
DEFAULT_FILE = SYSCONFPATH + "/cmdctl-accounts.csv"

ACTION_ADD = "add"
ACTION_DELETE = "delete"

# Non-zero return codes, used in tests
BAD_ARGUMENTS = 1
FILE_ERROR = 2
USER_EXISTS = 3
USER_DOES_NOT_EXIST = 4

class UserManager:
    def __init__(self, options, args):
        self.options = options
        self.args = args

    def print(self, msg):
        if not self.options.quiet:
            print(msg)

    def gen_password_hash(self, password):
        salt = "".join(chr(random.randint(33, 127)) for x in range(64))
        saltedpwd = sha1((password + salt).encode()).hexdigest()
        return salt, saltedpwd

    def username_exists(self, name):
        if not os.path.exists(self.options.output_file):
            return False

        exist = False
        csvfile = None
        with open(self.options.output_file) as csvfile:
            reader = csv.reader(csvfile)
            for row in reader:
                if name == row[0]:
                    exist = True
                    break
        return exist

    def save_userinfo(self, username, pw, salt, filename):
        csvfile = open(filename, 'a')
        writer = csv.writer(csvfile)
        writer.writerow([username, pw, salt])
        csvfile.close()
        self.print("User added\n")

    def add_user(self, name, password):
        """
        Add the given username/password combination to the file.
        First checks if the username exists, and returns False if so.
        If not, it is added, and this method returns True.
        (if it cannot write to the file it raises an exception)
        """
        if self.username_exists(name):
            return False
        salt, pw = self.gen_password_hash(password)
        self.save_userinfo(name, pw, salt, self.options.output_file)
        return True

    def delete_user(self, name):
        if not self.username_exists(name):
            return False
        rows = []
        with open(self.options.output_file) as csvfile:
            reader = csv.reader(csvfile)
            for row in reader:
                if row[0] != name:
                    rows.append(row)
        with open(self.options.output_file, 'w') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerows(rows)
        return True

    def prompt_for_username(self, action):
        while True :
            name = input("Username to " + action + ": ")
            if name == "":
                # Note, direct print here is intentional
                print("Error username can't be empty")
                continue

            if action == ACTION_ADD and self.username_exists(name):
                 print("user already exists")
                 continue
            elif action == ACTION_DELETE and not self.username_exists(name):
                 print("user does not exist")
                 continue

            return name

    def prompt_for_password(self):
        while True:
            pwd1 = getpass.getpass("Choose a password: ")
            if pwd1 == "":
                # Note, direct print here is intentional
                print("Error: password cannot be empty")
                continue
            pwd2 = getpass.getpass("Re-enter password: ")
            if pwd1 != pwd2:
                print("passwords do not match, try again")
                continue
            return pwd1

    def verify_options_and_args(self):
        """
        Basic sanity checks on command line arguments
        """
        if len(self.args) < 1:
            self.print("Error: must specify an action")
            return False
        if len(self.args) > 3:
            self.print("Error: extraneous arguments")
            return False
        if self.args[0] not in [ ACTION_ADD, ACTION_DELETE ]:
            self.print("Error: action must be either add or delete")
            return False
        if self.args[0] == ACTION_DELETE and len(self.args) > 2:
            self.print("Error: delete only needs username, not a password")
            return False
        return True

    def run(self):
        if not self.verify_options_and_args():
            return BAD_ARGUMENTS

        try:
            self.print("Using accounts file: " + self.options.output_file)

            action = self.args[0]

            if len(self.args) > 1:
                username = self.args[1]
            else:
                username = self.prompt_for_username(action)

            if action == ACTION_ADD:
                if len(self.args) > 2:
                    password = self.args[2]
                else:
                    password = self.prompt_for_password()
                if not self.add_user(username, password):
                    print("Error: username exists")
                    return USER_EXISTS
            elif action == ACTION_DELETE:
                if not self.delete_user(username):
                    print("Error: username does not exist")
                    return USER_DOES_NOT_EXIST

            return 0
        except IOError as ioe:
            self.print("Error accessing " + ioe.filename +\
                       ": " + str(ioe.strerror))
            return FILE_ERROR

def set_options(parser):
    parser.add_option("-f", "--file",
                      dest="output_file", default=DEFAULT_FILE,
                      help="Accounts file to modify"
                     )
    parser.add_option("-q", "--quiet",
                      dest="quiet", action="store_true", default=False,
                      help="Quiet mode, don't print any output"
                     )

def main():
    usage = "usage: %prog [options] <action> [username] [password]\n\n"\
            "Arguments:\n"\
            "  action\t\teither 'add' or 'delete'\n"\
            "  username\t\tthe username to add or delete\n"\
            "  password\t\tthe password to set for the added user\n"\
            "\n"\
            "If username or password are not specified, %prog will\n"\
            "prompt for them."
    parser = OptionParser(usage=usage, version=VERSION_STRING)
    set_options(parser)
    (options, args) = parser.parse_args()

    usermgr = UserManager(options, args)
    return usermgr.run()

if __name__ == '__main__':
    result = main()
    sys.exit(result)

