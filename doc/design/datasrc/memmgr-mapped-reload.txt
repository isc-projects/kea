@startuml

participant memmgr as "memmgr"
[-> memmgr: reload\n(zonename)
activate memmgr

participant list as "Configurable\nClientList"
memmgr -> list: getCachedZoneWriter\n(zone_name)
activate list

participant CacheConfig

participant zt_segment as "ZoneTable\nSegment\n(Mapped)"
participant segment as "Memory\nSegment\n(Mapped)"
participant segment.2 as "Memory\nSegment\n(Mapped)\n2"

list -> zt_segment: isWritable()
activate zt_segment
zt_segment --> list: true
deactivate zt_segment

list -> CacheConfig: getLoadAction()
activate CacheConfig

participant ZoneTable
participant ZoneWriter

create LoadAction
CacheConfig -> LoadAction: <<construct>>
CacheConfig --> list: LoadAction
deactivate CacheConfig

create ZoneWriter
list -> ZoneWriter: <<construct>> (LoadAction)
list --> memmgr: ZoneWriter
deactivate list

memmgr -> ZoneWriter: load()
activate ZoneWriter
ZoneWriter -> LoadAction: (funcall)
activate LoadAction

participant ZoneData

create ZoneData.2
LoadAction -> ZoneData.2: <<construct>> via helpers

LoadAction --> ZoneWriter: ZoneData.2
deactivate LoadAction
deactivate ZoneWriter

memmgr -> ZoneWriter: install()
activate ZoneWriter

ZoneWriter -> ZoneTable: addZone(ZoneData.2)
activate ZoneTable
ZoneTable --> ZoneWriter: ZoneData (old data)
deactivate ZoneTable

deactivate ZoneWriter

memmgr -> ZoneWriter: cleanup()
activate ZoneWriter

ZoneWriter -> ZoneData: <<destroy>>
destroy ZoneData
deactivate ZoneWriter

[<- memmgr: command to\nmodules\n(datasrc_name,\nsegmentparam)
[--> memmgr: ack from all\nmodules

memmgr -> list: resetMemorySegment\n(datasrc_name,\nREAD_WRITE,\nsegmentparam)
activate list

list -> zt_segment: reset\n(READ_WRITE,\nsegmentparam)
activate zt_segment

zt_segment -> segment: <<destroy>>
destroy segment
create segment.2
zt_segment -> segment.2: <<construct>>

deactivate zt_segment
deactivate list

note left of memmgr: (repeat the\nsame sequence\nfor loading to the\nother segment)

memmgr -> list: getCachedZoneWriter\n(zone_name)

...

@enduml
