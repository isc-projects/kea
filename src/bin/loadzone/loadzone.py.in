#!@PYTHON@

# Copyright (C) 2012  Internet Systems Consortium.
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SYSTEMS CONSORTIUM
# DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
# INTERNET SYSTEMS CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
# FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
# WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import sys
sys.path.append('@@PYTHONPATH@@')
from optparse import OptionParser
from isc.dns import *
from isc.datasrc import *
import isc.log
from isc.log_messages.loadzone_messages import *

isc.log.init("b10-loadzone", buffer=False)
logger = isc.log.Logger("loadzone")

class BadArgument(Exception):
    '''An exception indicating an error in command line argument.

    '''
    pass

class LoadFailure(Exception):
    '''An exception indicating failure in loading operation.

    '''
    pass

def set_cmd_options(parser):
    '''Helper function to set command-line options.

    '''
    parser.add_option("-v", "--verbose", dest="verbose", action="store_true",
            help="display more about what is going on")

class LoadZoneRunner:
    '''TBD

    '''
    def __init__(self, command_args):
        self.__command_args = command_args

        # These are essentially private, and defined as "protected" for the
        # convenience of tests inspecting them
        self._zone_class = None
        self._zone_name = None
        self._zone_file = None

    def _parse_args(self):
        usage_txt = 'usage: %prog [options] zonename zonefile'
        parser = OptionParser(usage=usage_txt)
        set_cmd_options(parser)
        (options, args) = parser.parse_args(args=self.__command_args)
        if len(args) != 2:
            raise BadArgument('Unexpected number of arguments: %d (must be 2)'
                              % (len(args)))
        try:
            self._zone_name = Name(args[0])
        except Exception as ex: # too broad, but there's no better granurality
            raise BadArgument("Invalid zone name '" + args[0] + "': " +
                              str(ex))

    def __cancel_create(self):
        '''sqlite3-only hack: delete the zone just created on load failure.

        This should eventually be done via generic datasrc API, but right now
        we don't have that interface.  Leaving the zone in this situation
        is too bad, so we handle it with a workaround.

        '''
        if self._datasrc_type is not 'sqlite3':
            return

        import sqlite3          # we need the module only here
        import json

        # If we are here, the following should basically succeed; since
        # this is considered a temporary workaround we don't bother to catch
        # and recover rare failure cases.
        dbfile = json.loads(self._datasrc_config)['database_file']
        with sqlite3.connect(dbfile) as conn:
            cur = conn.cursor()
            cur.execute("DELETE FROM zones WHERE name = ?",
                        [self._zone_name.to_text()])

    def _do_load(self):
        created = False
        try:
            datasrc_client = DataSourceClient(self._datasrc_type,
                                              self._datasrc_config)
            created = datasrc_client.create_zone(self._zone_name)
            if created:
                logger.info(LOADZONE_ZONE_CREATED, self._zone_name,
                            self._zone_class)
            loader = ZoneLoader(datasrc_client, self._zone_name,
                                self._zone_file)
            loader.load()
            return
        except Exception as ex:
            # release any remaining lock held in the client/loader
            loader, datasrc_client = None, None
            if created:
                self.__cancel_create()
                logger.error(LOADZONE_CANCEL_CREATE_ZONE, self._zone_name,
                             self._zone_class)
            raise LoadFailure(str(ex))

    def run(self):
        try:
            self._parse_args()
            self._do_load()
        except BadArgument as ex:
            logger.error(LOADZONE_ARGUMENT_ERROR, ex)
        except LoadFailure as ex:
            logger.error(LOADZONE_LOAD_ERROR, self._zone_name,
                         self._zone_class, ex)
        return 0

if '__main__' == __name__:
    runner = LoadZoneRunner(sys.argv[1:])
    ret = runner.run()
    sys.exit(ret)

## Local Variables:
## mode: python
## End:
