# Copyright (C) 2011  Internet Systems Consortium, Inc. ("ISC")
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
# OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.

$PREFIX DATASRC_
$NAMESPACE isc::datasrc

# \brief Messages for the data source library

CACHE_CREAT creating the hotspot cache
+ Debug information that the hotspot cache was created at startup.

CACHE_DESTROY destroying the hotspot cache
+ Debug information. The hotspot cache is being destroyed.

CACHE_INSERT inserting item '%1' into the cache
+ Debug information. It means a new item is being inserted into the hotspot
+ cache.

CACHE_OLD_FOUND older instance of cache item found, replacing
+ Debug information. While inserting an item into the hotspot cache, an older
+ instance of an item with the same name was found. The old instance will be
+ removed. This should be directly followed by CACHE_REMOVE.

CACHE_FULL cache is full, dropping oldest
+ Debug information. After inserting an item into the hotspot cache, the
+ maximum number of items was exceeded, so the least recently used item will
+ be dropped. This should be directly followed by CACHE_REMOVE.

CACHE_REMOVE removing '%1' from the cache
+ Debug information. An item is being removed from the hotspot cache.

CACHE_LOOKUP looking up '%1' in the cache
+ Debug information. We are trying to look up an item in the hotspot cache.
+ Further progress and result will follow.

CACHE_NOT_FOUND the item was not found
+ Debug information. The item we tried to look in the last CACHE_LOOKUP was
+ not found in the hotspot cache.

CACHE_FOUND the item was found
+ Debug information. The last CACHE_LOOKUP was successful, eg. we have found
+ the requested item in the hotspot cache.

CACHE_EXPIRED the item is expired
+ Debug information. The item requested in the last CACHE_LOOKUP was in the
+ hotspot cache, but it was old. We're going to remove it and report we don't
+ have it (the external result will be the same as with CACHE_NOT_FOUND).

CACHE_SLOTS setting the cache size to '%1'
+ The maximum allowed number of items of the hotspot cache is set to the given
+ number. If there are too many, we're going to drop them right now. The size
+ of 0 means no limit.

CACHE_ENABLE enabling the cache
+ The hotspot cache is enabled from now on.

CACHE_DISABLE disabling the cache
+ The hotspot cache is disabled from now on. It is not going to store
+ information or return anything.

QUERY_SYNTH_CNAME synthesizing CNAME from DNAME on '%1'
+ Debug info. While answering a query, we met a DNAME. We'll return the DNAME,
+ but we're creating a CNAME for clients that don't understand DNAMEs.

QUERY_EMPTY_DNAME the DNAME on '%1' is empty
+ We tried to synthesize a CNAME from this DNAME, but it contains no records.
+ This indicates problem with supplied data.

QUERY_GET_NS_ADDITIONAL addition of A/AAAA for '%1' requested by NS '%2'
+ Debug information. While processing a query, we met a NS record. It
+ references the mentioned address, so we want to look up A/AAAA records for it
+ and put it into the additional section.

QUERY_GET_MX_ADDITIONAL addition of A/AAAA for '%1' requested by MX '%2'
+ Debug information. While processing a query, we met a MX record. It
+ references the mentioned address, so we want to look up A/AAAA records for it
+ and put it into the additional section.

QUERY_FOLLOW_CNAME following CNAME at '%1'
+ Debug information. The domain is a CNAME (or a DNAME and we created a CNAME
+ for it already), so we're following it.

QUERY_EMPTY_CNAME cNAME at '%1' is empty
+ We tried to follow a CNAME, but contains no records. We have nothing to
+ follow, so we will have nothing in the answer. This indicates a problem with
+ supplied data.

QUERY_TOO_MANY_CNAMES cNAME chain limit exceeded at '%1'
+ While answering a query, we followed a CNAME. Then another one. And after 16
+ CNAMEs we decided it's enough and we won't follow more. Long CNAME chains
+ are discouraged, and this might be a loop as well. Note that some of the
+ CNAMEs might have been synthesised from DNAMEs internally. This indicates
+ a problem with supplied data.

QUERY_CHECK_CACHE checking cache for '%1/%2'
+ Debug information. While processing a query we're looking into the hotspot
+ cache.

QUERY_NO_CACHE_ANY_SIMPLE ignoring cache for ANY query
+ Debug information. We don't really want to use cache for simple ANY query
+ (ANY as the type or class).

QUERY_NO_CACHE_ANY_AUTH ignoring cache for ANY query
+ Debug information. We don't really want to use cache for authoritative ANY
+ query (ANY as the type or class).

DO_QUERY handling query for '%1/%2'
+ Debug information. We're processing some internal query for given name and
+ type.

QUERY_NO_ZONE no zone containing '%1' in class '%2'
+ We tried to get the domain but there's no zone in our data that encloses
+ the name. Maybe someone sent a query to wrong server for some reason.

QUERY_CACHED data found in cache
+ Debug information. We found the requested data in cache, so we're not
+ querying the real data source.

QUERY_IS_SIMPLE simple query
+ Debug information. The last DO_QUERY is a simple query.

QUERY_IS_AUTH auth query
+ Debug information. The last DO_QUERY is an auth query.

QUERY_IS_GLUE glue query
+ Debug information. The last DO_QUERY is query for glue addresses.

QUERY_IS_NOGLUE query for non-glue addresses
+ Debug information. The last DO_QUERY is query for addresses that are not
+ glue.

QUERY_IS_REF query for referral
+ Debug information. The last DO_QUERY is query for referral information.

QUERY_SIMPLE_FAIL the underlying data source failed with %1
+ We queried the data source to answer a simple query and it returned error
+ (1 is some error, 2 is not implemented). The data source should have log
+ the specific error already.

QUERY_AUTH_FAIL the underlying data source failed with %1
+ We queried the data source to answer authoritative query and it returned
+ error (1 is some error, 2 is not implemented). The data source should have
+ log the specific error already.

QUERY_GLUE_FAIL the underlying data source failed with %1
+ We queried the data source to answer query for glue addresses and it returned
+ error (1 is some error, 2 is not implemented). The data source should have
+ log the specific error already.

QUERY_NOGLUE_FAIL the underlying data source failed with %1
+ We queried the data source to answer query for non-glue addresses and it
+ returned error (1 is some error, 2 is not implemented). The data source
+ should have log the specific error already.

QUERY_REF_FAIL the underlying data source failed with %1
+ We queried the data source to answer query for referral and it
+ returned error (1 is some error, 2 is not implemented). The data source
+ should have log the specific error already.

QUERY_INVALID_OP invalid query operation requested
+ This indicates a programmer error. The DO_QUERY was called with unknown
+ operation code.

QUERY_ADD_RRSET adding RRset '%1/%2' to message
+ Debug information. We're adding the rrset to answer message.

QUERY_COPY_AUTH copying authoritative section into message
+ Debug information. We're copying referral information into authoritative
+ section of the response message.

QUERY_DELEGATION looking for delegation on the path to '%1'
+ Debug information. We're looking if there's a delegation point on the way
+ down to the given domain.

QUERY_ADD_SOA adding SOA of '%1'
+ Debug information. We're adding a SOA record for the given zone into the
+ authority section.

QUERY_ADD_NSEC adding NSEC record for '%1'
+ Debug information. We're adding NSEC record for this domain.

QUERY_ADD_NSEC3 adding NSEC3 record of zone '%1'
+ Debug information. We're adding an NSEC3 record for this zone.

QUERY_NO_DS_NSEC3 there's no DS record in the '%1' zone
+ We tried to insert a NSEC3 record into the message. But we didn't find a DS
+ record for this zone.

QUERY_NO_DS_NSEC there's no DS record in the '%1' zone
+ We tried to insert a NSEC record into the message. But we didn't find a DS
+ record for this zone.

QUERY_WILDCARD looking for a wildcard covering '%1'
+ Debug information. We didn't find a direct match, so we're trying to find if
+ there's a wildcard we could use to answer the query.

QUERY_WILDCARD_PROVENX_FAIL unable to prove nonexistence of '%1' (%2)
+ While processing a wildcard, we tried to prove nonexistence of the given
+ domain or record. The code is 1 for error and 2 for not implemented.

QUERY_WILDCARD_REFERRAL unable to find referral info for '%1' (%2)
+ While processing a wildcard we met a referral. But we were not able to get
+ information for it. The code is 1 for error, 2 for not implemented.

QUERY_PROCESS processing query '%1/%2' in the '%3' class
+ Debug information. We're starting to process a user query.

QUERY_RRSIG unable to answer RRSIG query
+ The server is unable to answer a direct query for RRSIG type, but was asked
+ to do so.

QUERY_MISPLACED_TASK task of this type should not be here
+ This indicates a programming error. We found a task in the internal task
+ queue which wasn't supposed to ever be put into the queue, but handled
+ directly.

QUERY_TASK_FAIL task failed with %1
+ The query subtask failed. The reason should have been reported by the subtask
+ already. The code is 1 for error, 2 for not implemented.

QUERY_MISSING_NS missing NS records for '%1'
+ We wanted to put the nameserver records into the authority section, but we
+ discovered the zone doesn't have them. This indicates problem with provided
+ data.

UNEXPECTED_QUERY_STATE unexpected query state
+ This indicates a programming error. We generated an internal task of type
+ unknown to us.

QUERY_FAIL query failed
+ Some subtask of query processing failed. The reason should have been reported
+ already. We are returning SERVFAIL.

QUERY_BAD_REFERRAL bad referral to '%1'
+ We discovered that the domain lives in another zone. But we are not able to
+ generate referral information to it.

QUERY_WILDCARD_FAIL error processing wildcard for '%1'
+ We tried to find a wildcard to cover the domain, but there happened to be
+ some (hopefully already reported) error for it.

QUERY_MISSING_SOA the zone '%1' has no SOA
+ We tried to answer negatively, but there's no SOA record in the zone.

QUERY_PROVENX_FAIL unable to prove nonexistence of '%1'
+ The user wants DNSSEC and we discovered the entity doesn't exist (either
+ domain or the record). But there was an error getting NSEC/NSEC3 record
+ to prove the nonexistence.

QUERY_UNKNOWN_RESULT unknown result of subtask
+ This indicates a programmer error. The answer of subtask doesn't look like
+ anything we would know.

META_ADD adding a data source into meta data source
+ Debug information. We add yet another data source into the meta data source
+ (probably at startup or reconfiguration).

META_ADD_CLASS_MISMATCH mismatch between classes '%1' and '%2'
+ We tried to add a data source of one class into a meta data source of a
+ different type. The types must be the same.

META_REMOVE removing data source from meta data source
+ Debug information. We take a data source out of meta data source (probably
+ at shutdown or reconfiguration).

MEM_ADD_WILDCARD adding wildcards for '%1'
+ Debug information. We need some special marks above each * in wildcard name
+ in the in-memory data source. We are adding the marks for this name now.

MEM_CNAME_TO_NONEMPTY can't add CNAME to domain with other data in '%1'
+ Someone or something tried to add a CNAME into a domain that already contains
+ some other data. But the protocol forbids coexistence of CNAME with anything
+ (RFC 1034, section 3.6.2). This indicates a problem with provided data.

MEM_CNAME_COEXIST can't add data to CNAME in domain '%1'
+ This is the same problem as in MEM_CNAME_TO_NONEMPTY, but it happened the
+ other way around -- adding some outher data to CNAME.

MEM_DNAME_NS dNAME and NS can't coexist in non-apex domain '%1'
+ It was requested for DNAME and NS records to be put into the same domain
+ which is not the apex (the top of the zone). This is forbidden by RFC
+ 2672, section 3. This indicates a problem with provided data.

MEM_SINGLETON trying to add multiple RRs for domain '%1' and type '%2'
+ Some resource types are singletons -- only one is allowed in a domain
+ (for example CNAME or SOA). This indicates a problem with provided data.

MEM_OUT_OF_ZONE domain '%1' doesn't belong to zone '%2'
+ It was attempted to add the domain into a zone that shouldn't have it
+ (eg. the domain is not subdomain of the zone origin). This indicates a
+ problem with provided data.

MEM_WILDCARD_NS nS record in wildcard domain '%1'
+ We refuse to load NS record into a wildcard domain. It is'n explicitly
+ forbidden, but the protocol is ambiguous about how this should behave and
+ bind 9 refuses that as well. We don't like your zone, please describe it
+ using different tools.

MEM_WILDCARD_DNAME dNAME record in wildcard domain '%1'
+ We refuse to load DNAME record into a wildcard domain. It is'n explicitly
+ forbidden, but the protocol is ambiguous about how this should behave and
+ bind 9 refuses that as well. We don't like your zone, please describe it
+ using different tools.

MEM_ADD_RRSET adding RRset '%1/%2' into zone '%3'
+ Debug information. We're adding an RRset to the zone of in-memory data
+ source.

MEM_DUP_RRSET duplicate rrset '%1/%2'
+ An RRset is being inserted into in-memory data source for a second time.
+ The original version must be removed first. Note that we don't support
+ loading master files where an RRset is split into multiple locations yet.

MEM_DNAME_ENCOUNTERED encountered a DNAME
+ Debug information. While searching for the requested domain, we encountered
+ a DNAME on the way. This may lead to redirection to a different domain and
+ stop the search.

MEM_NS_ENCOUNTERED encountered a NS
+ Debug information. While searching for the requested domain, we encountered
+ a NS on the way (a delegation). This may lead to stop of the search.

MEM_RENAME renaming rrset from '%1' to '%2'
+ Debug information. We generate an RRset from a different RRset (most probably
+ a wildcard). So we need to rename it to whatever the user asked for. In fact,
+ we can't rename RRset (it's not possible with our libraries), so we create
+ a new one and copy everything.

MEM_FIND find '%1/%2'
+ Debug information. We're going to search the in-memory data source to find
+ requestet RRset.

MEM_DNAME_FOUND dNAME found at '%1'
+ Debug information. We found a DNAME instead of the requested record.

MEM_DELEG_FOUND delegation found at '%1'
+ Debug information. We found a delegation point above the requested record.

MEM_SUPER_STOP stopped at superdomain, domain is empty
+ Debug information. The search stopped at a superdomain of the requested
+ domain. The domain is a empty nonterminal, therefore we treat it as NXRRSET
+ case (eg. the domain exists, but it doesn't have the requested record type).

MEM_WILDCARD_CANCEL wildcard match canceled
+ Debug information. We reached a domain above wildcard, but there's something
+ below the requested domain. Therefore the wildcard doesn't apply here.
+ This behaviour is specified by RFC 1034, section 4.3.3

MEM_NOTFOUND requested domain not found
+ Debug information. The requested domain does not exist.

MEM_DOMAIN_EMPTY requested domain is empty
+ Debug information. The requested domain exists in the tree of domains, but
+ it is empty. Therefore it doesn't contain the requested resource type.

MEM_EXACT_DELEGATION delegation at the exact domain
+ Debug information. There's a NS record at the requested domain. This means
+ this zone is not authoritative for the requested domain, but a delegation
+ should be followed. The requested domain is an apex of some zone.

MEM_ANY_SUCCESS aNY query successful
+ Debug information. The domain was found and we answer an ANY type query by
+ providing everything we found inside the domain.

MEM_SUCCESS query successful
+ Debug information. We found the record we searched for.

MEM_CNAME cNAME at the domain
+ Debug information. The requested domain is an alias to a different domain,
+ returning the CNAME instead.

MEM_NXRRSET no such type
+ Debug information. The domain exists, but it doesn't hold any record of the
+ requested type.

MEM_CREATE creating zone '%1' in '%2' class
+ Debug information. We're creating representation of a zone for the in-memory
+ data source.

MEM_DESTROY destroying zone '%1' in '%2' class
+ Debug information. We're destroying the representation of zone in the
+ in-memory data source.

MEM_LOAD loading zone '%1' from file '%2'
+ Debug information. We're loading the content of zone from a master file.

MEM_SWAP swapping contents of two zone representations ('%1' and '%2')
+ Debug information. We exchange contents of the zones. This is usual practice
+ to do some manipulation in exception-safe manner -- we prepare the new data
+ in a different zone object and when it works, we swap it with the old, then
+ we can safely destroy the old one.

MEM_ADD_ZONE adding zone '%1/%2'
+ Debug information. We're adding this zone into the in-memory data source.

MEM_FIND_ZONE looking for zone '%1'
+ Debug information. We're looking for a zone in the in-memory data source.

STATIC_CREATE creating the static datasource
+ Debug information. We're creating the static data source (the one holding
+ stuff like version.bind).

STATIC_BAD_CLASS static data source can handle CH only
+ For some reason, someone asked the static data source a query that is not in
+ the CH class.

STATIC_FIND looking for '%1/%2'
+ Debug information. We're looking for this resource record set in the static
+ data source.

SQLITE_FINDREC looking for record '%1/%2'
+ Debug information. The SQLite data source is looking up records of given name
+ and type in the database.

SQLITE_ENCLOSURE looking for zone containing '%1'
+ Debug information. The SQLite data source is trying to identify, which zone
+ should hold this domain.

SQLITE_ENCLOSURE_BAD_CLASS class mismatch looking for a zone ('%1' and '%2')
+ The SQLite data source can handle only one class at a time and it was asked
+ to identify which zone is holding data of a different class.

SQLITE_ENCLOSURE_NOTFOUND no zone contains it
+ Debug information. The last SQLITE_ENCLOSURE query was unsuccessful, there's
+ no such zone in our data.

SQLITE_PREVIOUS looking for name previous to '%1'
+ Debug information. We're trying to look up name preceding the supplied one.

SQLITE_PREVIOUS_NO_ZONE no zone containing '%1'
+ The SQLite data source tried to identify name preceding this one. But this
+ one is not contained in any zone in the data source.

SQLITE_FIND_NSEC3 looking for NSEC3 in zone '%1' for hash '%2'
+ Debug information. We're trying to look up a NSEC3 record in the SQLite data
+ source.

SQLITE_FIND_NSEC3_NO_ZONE no such zone '%1'
+ The SQLite data source was asked to provide a NSEC3 record for given zone.
+ But it doesn't contain that zone.

SQLITE_FIND looking for RRset '%1/%2'
+ Debug information. The SQLite data source is looking up a resource record
+ set.

SQLITE_FIND_BAD_CLASS class mismatch looking for an rrset ('%1' and '%2')
+ The SQLite data source was looking up an RRset, but the data source contains
+ different class than the query was for.

SQLITE_FINDEXACT looking for exact RRset '%1/%2'
+ Debug information. The SQLite data source is looking up an exact resource
+ record.

SQLITE_FINDEXACT_BAD_CLASS class mismatch looking for an rrset ('%1' and '%2')
+ The SQLite data source was looking up an exact RRset, but the data source
+ contains different class than the query was for.

SQLITE_FINDADDRS looking for A/AAAA addresses for '%1'
+ Debug information. The data source is looking up the addresses for given
+ domain name.

SQLITE_FINDADDRS_BAD_CLASS class mismatch looking for addresses ('%1' and '%2')
+ The SQLite data source was looking up A/AAAA addresses, but the data source
+ contains different class than the query was for.

SQLITE_FINDREF looking for referral at '%1'
+ Debug information. The SQLite data source is identifying if this domain is
+ a referral and where it goes.

SQLITE_FINDREF_BAD_CLASS class mismatch looking for referral ('%1' and '%2')
+ The SQLite data source was trying to identify, if there's a referral. But the
+ but it contains different class than the query was for.

SQLITE_CREATE sQLite data source created
+ Debug information. We're creating an instance of the SQLite data source.

SQLITE_DESTROY sQLite data source destroyed
+ Debug information. We're destroying an instance of SQLite data source.

SQLITE_SETUP setting up SQLite database
+ The database for SQLite data source was found empty. So we're assuming this
+ is the first run and we initialize it with current schema. It'll still
+ contain no data, but it will be ready for use.

SQLITE_OPEN opening SQLite database '%1'
+ Debug information. The SQLite data source is loading an SQLite database in
+ the provide file.

SQLITE_CLOSE closing SQLite database
+ Debug information. The SQLite data source is closing the database file.
