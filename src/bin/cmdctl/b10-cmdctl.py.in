# Copyright (C) 2010  Internet Systems Consortium.
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SYSTEMS CONSORTIUM
# DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
# INTERNET SYSTEMS CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
# FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
# WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

''' cmdctl module is the configuration entry point for all commands from bindctl
or some other web tools client of bind10. cmdctl is pure https server which provi-
des RESTful API. When command client connecting with cmdctl, it should first login 
with legal username and password. 
    When cmdctl starting up, it will collect command specification and 
configuration specification/data of other available modules from configmanager, then
wait for receiving request from client, parse the request and resend the request to
the proper module. When getting the request result from the module, send back the 
resut to client.
'''
#!@PYTHON@

import sys; sys.path.append ('@@PYTHONPATH@@')
import http.server
import urllib.parse
import json
import re
import ssl, socket
import ISC
import pprint
import select
import csv
import random
from hashlib import sha1
try:
    import threading
except ImportError:
    import dummy_threading as threading

URL_PATTERN = re.compile('/([\w]+)(?:/([\w]+))?/?')
USER_INFO_FILE = "passwd.csv"
CERTIFICATE_FILE = 'b10-cmdctl.pem'
        
class SecureHTTPRequestHandler(http.server.BaseHTTPRequestHandler):
    '''https connection request handler.
    Currently only GET and POST are supported.
    '''

    def _check_username(self, name):
        if self.server.user_infos.get(name):
            return True
        return False
        
    
    def _check_password(self, name, password):
        if not password:
            return False
        else:
            info = self.server.user_infos.get(name)            
            datastr = (password + info[1]).encode()
            return sha1(datastr).hexdigest() == info[0]        

    def _process_user_login(self):
        # check username and password, if pass, record client's session id
        rcode, reply = http.client.UNAUTHORIZED, []        
        length = self.headers.get('content-length')
        if not length:
            reply = ["invalid username or password"]     
        else:
            user_info = json.loads((self.rfile.read(int(length))).decode())
            name = user_info.get('username')
            passwd = user_info.get('password')
            if not user_info:
                reply = ["invalid username or password"]                
            elif not self._check_username(name):
                reply = ["username doesn't exist"]    
            elif not self._check_password(name, passwd):
                reply = ["invalid password"]
            else:
                senid = self.headers.get('cookie')
                if not senid:
                    reply = ["need session id from client"]                
                else:
                    self.server.user_sessions.append(senid)
                    rcode, reply = http.client.OK, ["login success "]
    
        return rcode, reply
        
    
    def _parse_request_path(self, path):
        '''Parse the url, the legal url should like /ldh or /ldh/ldh '''
        groups = URL_PATTERN.match(path) 
        if not groups:
            return (None, None)

        return (groups.group(1), groups.group(2))

    def do_GET(self):
        ''' The client should send its session id in header with 
        the name 'cookie'
        '''
        rcode, reply = 200, []        
        senid = self.headers.get('cookie')
        if not senid:
            rcode = http.client.BAD_REQUEST
        else:
            if senid not in self.server.user_sessions:
                rcode, reply = http.client.UNAUTHORIZED, ["please login"]
            else:
                identifier, module = self._parse_request_path(self.path)   
                rcode, reply = self.server.get_reply_data_for_GET(identifier, module) 
                    
        self.send_response(rcode)
        self.end_headers()
        self.wfile.write(json.dumps(reply).encode())

        
    def do_POST(self):
        '''Process user login and send command to proper module  
        The client should send its session id in header with 
        the name 'cookie'
        '''
        rcode, reply = http.client.OK, []
        id = self.headers.get('cookie')
        if not id:
            rcode = http.client.BAD_REQUEST
        else:        
            if self.path == '/login':
                rcode, reply = self._process_user_login()
            elif id not in self.server.user_sessions:
                rcode, reply = http.client.UNAUTHORIZED, ["please login"]           
            else:
                mod, cmd = self._parse_request_path(self.path)
                param = None
                len = self.headers.get('Content-Length')
                if len:
                    post_str = str(self.rfile.read(int(len)).decode())
                    print("command parameter:%s" % post_str)
                    param = json.loads(post_str)
    
                # TODO, need return some proper return code. 
                # currently always OK.
                reply = self.server.send_command_to_module(mod, cmd, param)
                print('b10-cmdctl finish send message \'%s\' to module %s' % (cmd, mod))            
       
        self.send_response(rcode)
        self.end_headers()
        self.wfile.write(json.dumps(reply).encode())


class CommandControl():
    '''Get all modules' config data/specification from configmanager.
    receive command from client and resend it to proper module.
    '''

    def __init__(self):
        self.cc = ISC.CC.Session()
        self.cc.group_subscribe('Cmd-Ctrld')
        #self.cc.group_subscribe('Boss', 'Cmd-Ctrld')
        self.command_spec = self.get_cmd_specification()
        self.config_spec = self.get_data_specification()
        self.config_data = self.get_config_data()

    def get_cmd_specification(self): 
        return self.send_command('ConfigManager', 'get_commands')

    def get_config_data(self):
        return self.send_command('ConfigManager', 'get_config')

    def update_config_data(self, module_name, command_name):
        if module_name == 'ConfigManager' and command_name == 'set_config':
            self.config_data = self.get_config_data()

    def get_data_specification(self):
        return self.send_command('ConfigManager', 'get_data_spec')

    def handle_recv_msg(self):
        # Handle received message, if 'shutdown' is received, return False
        (message, env) = self.cc.group_recvmsg(True)
        while message:
            if 'commands_update' in message:
                self.command_spec[message['commands_update'][0]] = message['commands_update'][1]
            elif 'specification_update' in message:
                msgvalue = message['specification_update']
                self.config_spec[msgvalue[0]] = msgvalue[1]
            elif 'command' in message and message['command'][0] == 'shutdown':
                return False;
            (message, env) = self.cc.group_recvmsg(True)
        
        return True
    
    def send_command(self, module_name, command_name, params = None):       
        content = [command_name]
        if params:
            content.append(params)

        msg = {'command' : content}
        print('b10-cmdctl send command \'%s\' to %s' %(command_name, module_name))
        try:
            self.cc.group_sendmsg(msg, module_name)
            #TODO, it may be blocked, msqg need to add a new interface
            # wait in timeout.
            answer, env = self.cc.group_recvmsg(False)
            if answer and 'result' in answer.keys() and type(answer['result']) == list:
                # TODO: with the new cc implementation, replace "1" by 1
                if answer['result'][0] == 1:
                    # todo: exception
                    print("Error: " + str(answer['result'][1]))
                    return {}
                else:
                    self.update_config_data(module_name, command_name)
                    if len(answer['result']) > 1:
                        return answer['result'][1]
                    return {}
            else:
                print("Error: unexpected answer from %s" % module_name)
        except Exception as e:
            print(e)
            print('b10-cmdctl fail send command \'%s\' to %s' % (command_name, module_name))
        return {}


class SecureHTTPServer(http.server.HTTPServer):
    '''Make the server address can be reused.'''
    allow_reuse_address = True

    def __init__(self, server_address, RequestHandlerClass):
        http.server.HTTPServer.__init__(self, server_address, RequestHandlerClass)
        self.user_sessions = []
        self.cmdctrl = CommandControl()
        self.__is_shut_down = threading.Event()
        self.__serving = False
        self.user_infos = {}
        self._read_user_info()

    def _read_user_info(self):
        # Get all username and password information
        csvfile = None
        try:
            csvfile = open(USER_INFO_FILE)
            reader = csv.reader(csvfile)
            for row in reader:
                self.user_infos[row[0]] = [row[1], row[2]]
                
        except Exception as e:
            print("Fail to read user information ", e)                
            exit(1)
        finally:
            if csvfile:
                csvfile.close()
        
        
    def get_request(self):
        newsocket, fromaddr = self.socket.accept()
        try:
            connstream = ssl.wrap_socket(newsocket,
                                     server_side = True,
                                     certfile = CERTIFICATE_FILE,
                                     keyfile = CERTIFICATE_FILE,
                                     ssl_version = ssl.PROTOCOL_SSLv23)
            return (connstream, fromaddr)
        except ssl.SSLError as e :
            print("cmdctl: deny client's invalid connection", e)
            self.close_request(newsocket)
            # raise socket error to finish the request
            raise socket.error
            
    
    def get_reply_data_for_GET(self, id, module):
        '''Currently only support the following three url GET request '''
        rcode, reply = http.client.NO_CONTENT, []        
        if not module:
            if id == 'command_spec':
                rcode, reply = http.client.OK, self.cmdctrl.command_spec
            elif id == 'config_data':
                rcode, reply = http.client.OK, self.cmdctrl.config_data
            elif id == 'config_spec':
                rcode, reply = http.client.OK, self.cmdctrl.config_spec
        
        return rcode, reply     
            

    def serve_forever(self, poll_interval = 0.5):
        self.__serving = True
        self.__is_shut_down.clear()
        while self.__serving:
            if not self.cmdctrl.handle_recv_msg():
                break

            r, w, e = select.select([self], [], [], poll_interval)
            if r:
                self._handle_request_noblock()

        self.__is_shut_down.set()
    
    def shutdown(self):
        self.__serving = False
        self.__is_shut_down.wait()


    def send_command_to_module(self, module_name, command_name, params):
        return self.cmdctrl.send_command(module_name, command_name, params)


def run(server_class = SecureHTTPServer, addr = 'localhost', port = 8080):
    ''' Start cmdctl as one https server. '''
    print("b10-cmdctl module is starting on :%s port:%d" %(addr, port))
    httpd = server_class((addr, port), SecureHTTPRequestHandler)
    httpd.serve_forever()


if __name__ == '__main__':
    try:
        run()
    except ISC.CC.SessionError as se:
        print("[b10-cmdctl] Error creating b10-cmdctl, "
                "is the command channel daemon running?")        
    except KeyboardInterrupt:
        print("exit http server")
        

