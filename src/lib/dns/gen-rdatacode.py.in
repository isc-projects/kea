#!@PYTHON@

# Copyright (C) 2010  Internet Systems Consortium, Inc. ("ISC")
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
# OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.

# $Id$

"""\
This is a supplemental script to (half) auto-generate DNS Rdata related
classes and constants.
"""

import os
from os.path import getmtime
import re
import sys

re_typecode = re.compile('([\da-z]+)_(\d+)')
classcode2txt = {}
typecode2txt = {}
typeandclass = []
generic_code = 65536            # something larger than any code value
rdata_declarations = ''
class_definitions = ''
classdir_mtime = 0
rdatadef_mtime = 0
rdatahdr_mtime = 0
heading_txt = '''///////////////
///////////////
///////////////   THIS FILE IS AUTOMATICALLY GENERATED BY gen-rdatacode.py.
///////////////   DO NOT EDIT!
///////////////
///////////////

'''

def import_classdef(class_txt, file):
    content = ''
    rdata_source = open(file, 'r')
    for line in rdata_source.readlines():
        if re.match('// BEGIN_ISC_NAMESPACE', line):
            content += 'namespace isc {\n'
            content += 'namespace dns {\n'
            continue
        if re.match('// BEGIN_RDATA_NAMESPACE', line):
            content += 'namespace rdata {\n'
            content += 'namespace ' + class_txt + ' {\n'
            continue
        if re.match('// END_ISC_NAMESPACE', line):
            content += '} // end of namespace "dns"\n'
            content += '} // end of namespace "isc"\n'
            continue
        if re.match('// END_RDATA_NAMESPACE', line):
            content += '} // end of namespace "' + class_txt +'"\n'
            content += '} // end of namespace "rdata"\n'
            continue
        content += line
    rdata_source.close()
    return content

def import_classheader(class_txt, type_txt, type_code, file):
    type_utxt = type_txt.upper()
    class_utxt = class_txt.upper()

    # for each CLASS_n/TYPE_m.h
    rdata_header = open(file, 'r')
    content = ''
    guard_macro = '__' + class_txt.upper() + '_' + type_txt.upper()
    guard_macro += '_' + type_code + '_H'
    for line in rdata_header.readlines():
        if re.match('// BEGIN_HEADER_GUARD', line):
            content += '#ifndef ' + guard_macro + '\n'
            content += '#define ' + guard_macro + ' 1\n'
            continue
        if re.match('// END_HEADER_GUARD', line):
            content += '#endif // ' + guard_macro + '\n'
            continue
        if re.match('// BEGIN_ISC_NAMESPACE', line):
            content += 'namespace isc {\n'
            content += 'namespace dns {\n'
            continue
        if re.match('// BEGIN_RDATA_NAMESPACE', line):
            content += 'namespace rdata {\n'
            content += 'namespace ' + class_txt + ' {\n'
            continue
        if re.match('// END_ISC_NAMESPACE', line):
            content += '} // end of namespace "dns"\n'
            content += '} // end of namespace "isc"\n'
            continue
        if re.match('// END_RDATA_NAMESPACE', line):
            content += '} // end of namespace "' + class_txt +'"\n'
            content += '} // end of namespace "rdata"\n'
            continue
        if re.match('// Local Variables:', line):
            break
        content += line
        if re.match('// BEGIN_COMMON_DECLARATIONS', line):
            content += '''
class InputBuffer;
class OutputBuffer;
class MessageRenderer;\n\n'''
        if re.match('\s+// BEGIN_COMMON_MEMBERS$', line):
            content += '''
    explicit ''' + type_utxt + '''(const std::string& type_str);
    ''' + type_utxt + '''(InputBuffer& buffer, size_t rdata_len);
    ''' + type_utxt + '''(const ''' + type_utxt + '''& other);
    virtual std::string toText() const;
    virtual void toWire(OutputBuffer& buffer) const;
    virtual void toWire(MessageRenderer& renderer) const;
    virtual int compare(const Rdata& other) const;\n\n'''
    rdata_header.close()
    return content

def import_definitions(classcode2txt, typecode2txt, typeandclass):
    global rdata_declarations
    global class_definitions
    global classdir_mtime
    global rdatadef_mtime
    global rdatahdr_mtime

    for dir in list(os.listdir('@srcdir@/rdata')):
        classdir = '@srcdir@/rdata' + os.sep + dir
        m = re_typecode.match(dir)
        if os.path.isdir(classdir) and (m != None or dir == 'generic'):
            if classdir_mtime < getmtime(classdir):
                classdir_mtime = getmtime(classdir)
            if dir == 'generic':
                class_txt = 'generic'
                class_code = generic_code
            else:
                class_txt = m.group(1)
                class_code = m.group(2)
                if not class_code in classcode2txt:
                    classcode2txt[class_code] = class_txt
            for file in list(os.listdir(classdir)):
                file = classdir + os.sep + file
                m = re_typecode.match(os.path.split(file)[1])
                if m != None:
                    type_txt = m.group(1)
                    type_code = m.group(2)
                    if not type_code in typecode2txt:
                        typecode2txt[type_code] = type_txt
                    if re.search('\cc$', file):
                        if rdatadef_mtime < getmtime(file):
                            rdatadef_mtime = getmtime(file)
                        class_definitions += import_classdef(class_txt, file)
                    elif re.search('\h$', file):
                        if rdatahdr_mtime < getmtime(file):
                            rdatahdr_mtime = getmtime(file)
                        rdata_declarations += import_classheader(class_txt,
                                                                 type_txt,
                                                                 type_code,
                                                                 file)
                        typeandclass.append((type_txt, int(type_code),
                                             (class_txt, class_txt),
                                             int(class_code)))
                        if class_txt == 'generic':
                            typeandclass.append((type_txt, int(type_code),
                                                 (class_txt, 'in'), 1))

def need_generate(file, mtime):
    '''Check if we need to generate the specified file.

    To avoid unnecessary compilation, we skip (re)generating the file when
    the file already exists and newer than the base file.
    '''
    if os.path.exists(file) and getmtime(file) > mtime:
        return False
    return True

def generate_rdatadef(file, basemtime):
    if not need_generate(file, basemtime):
        print('skip generating ' + file);
        return
    rdata_deffile = open(file, 'w')
    rdata_deffile.write(heading_txt)
    rdata_deffile.write(class_definitions)
    rdata_deffile.close()

def generate_rdatahdr(file, declarations, basemtime):
    if not need_generate(file, basemtime):
        print('skip generating ' + file);
        return
    declarations += '''
// Local Variables:
// mode: c++
// End:
'''
    rdata_header = open(file, 'w')
    rdata_header.write(heading_txt)
    rdata_header.write(declarations)
    rdata_header.close()

def generate_typeclasscode(fileprefix, basemtime, code2txt, type_or_class):
    placeholder = '@srcdir@/' + fileprefix + '-placeholder.h'
    outputfile = '@builddir@/' + fileprefix + '.h'
    upper_key = type_or_class.upper() # TYPE or CLASS
    lower_key = 'rr' + type_or_class.lower() # rrtype or rrclass
    cap_key = type_or_class           # Type or Class

    if not need_generate(outputfile, basemtime) and getmtime(outputfile) > getmtime(placeholder):
        print('skip generating ' + outputfile)
        return

    declarationtxt = ''
    deftxt = ''
    for code in code2txt.keys():
        codetxt = code2txt[code].upper()
        declarationtxt += ' ' * 4 + 'static const RR' + cap_key + '& ' + codetxt + '();\n'
        deftxt += '''inline const RR''' + cap_key + '''&
RR''' + cap_key + '''::''' + codetxt + '''()
{
    static RR''' + cap_key + ''' ''' + lower_key + '''(''' + code + ''');
    return (''' + lower_key + ''');
}\n
'''
    header_temp = open(placeholder, 'r')
    header_out = open(outputfile, 'w')
    header_out.write(heading_txt)
    for line in header_temp.readlines():
        header_out.write(line)
        if re.match('\s+// BEGIN_WELL_KNOWN_' + upper_key + '_DECLARATIONS$', line):
            header_out.write(declarationtxt)
        if re.match('// BEGIN_WELL_KNOWN_' + upper_key + '_DEFINITIONS$', line):
            header_out.write('\n' + deftxt)
    header_out.close()
    header_temp.close()

def generate_rrparam(fileprefix, basemtime):
    placeholder = '@srcdir@/' + fileprefix + '-placeholder.cc'
    outputfile = '@builddir@/' + fileprefix + '.cc'
    if not need_generate(outputfile, basemtime) and getmtime(outputfile) > getmtime(placeholder):
        print('skip generating ' + outputfile)
        return

    # sort by class, then by type
    typeandclassparams = ''
    typeandclass.sort(key = lambda x: (x[3], x[1]))
    for param in typeandclass:
        # for rrparamregistry.cc
        # each param is a tuple of (type_txt, type_code, class_tuple,
        #                           class_code)
        (type_txt, type_code, class_tuple, class_code) = param
        type_utxt = type_txt.upper()
        class_txt = class_tuple[0]
        class_utxt = class_tuple[1].upper()
        indent = ' ' * 8
        typeandclassparams += indent
        if class_tuple[1] != 'generic':
            typeandclassparams += 'add("' + type_utxt + '", '
            typeandclassparams += str(type_code) + ', "' + class_utxt
            typeandclassparams += '", ' + str(class_code)
            typeandclassparams += ', RdataFactoryPtr(new RdataFactory<'
            typeandclassparams += class_txt + '::' + type_utxt + '>()));\n'
        else:
            typeandclassparams += 'add("' + type_utxt + '", ' + str(type_code)
            typeandclassparams += ', RdataFactoryPtr(new RdataFactory<'
            typeandclassparams += class_txt + '::' + type_utxt + '>()));\n'

    rrparam_temp = open(placeholder, 'r')
    rrparam_out = open(outputfile, 'w')
    rrparam_out.write(heading_txt)
    for line in rrparam_temp.readlines():
        rrparam_out.write(line)
        if re.match('\s+// BEGIN_WELL_KNOWN_PARAMS', line):
            rrparam_out.write(typeandclassparams)
    rrparam_temp.close()
    rrparam_out.close()

if __name__ == "__main__":
    try:
        import_definitions(classcode2txt, typecode2txt, typeandclass)
        generate_rdatadef('@builddir@/rdataclass.cc', rdatadef_mtime)
        generate_rdatahdr('@builddir@/rdataclass.h', rdata_declarations,
                          rdatahdr_mtime)
        generate_typeclasscode('rrtype',
                               max(rdatadef_mtime, rdatahdr_mtime),
                               typecode2txt, 'Type')
        generate_typeclasscode('rrclass', classdir_mtime,
                               classcode2txt, 'Class')
        generate_rrparam('rrparamregistry', rdatahdr_mtime)
    except:
        sys.stderr.write('Code generation failed due to exception: %s\n' %
                         sys.exc_info()[1])
        exit(1)
