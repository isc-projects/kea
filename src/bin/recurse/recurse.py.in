#!@PYTHON@

# Copyright (C) 2010  Internet Systems Consortium.
# Copyright (C) 2010  CZ NIC
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SYSTEMS CONSORTIUM
# DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
# INTERNET SYSTEMS CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
# FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
# WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""
   This is a dummy recursor module, purely for testing that the changes to
   the Boss regarding the starting of recurse/auth works.  It should be deleted
   when the real recursor module is made available.
"""

import sys; sys.path.append ('@@PYTHONPATH@@')
import isc
import isc.cc
import threading
import struct
import signal
from isc.datasrc import sqlite3_ds
from socketserver import *
import os
from isc.config.ccsession import *
from isc.log.log import *
from isc.cc import SessionError, SessionTimeout
from isc.notify import notify_out
import isc.util.process
import socket
import select
import errno
from optparse import OptionParser, OptionValueError
from isc.util import socketserver_mixin

try:
    from libxfr_python import *
    from pydnspp import *
except ImportError as e:
    # C++ loadable module may not be installed; even so the recurse process
    # must keep running, so we warn about it and move forward.
    sys.stderr.write('[b10-recurse] failed to import DNS or XFR module: %s\n' % str(e))

isc.util.process.rename()

if "B10_FROM_BUILD" in os.environ:
    SPECFILE_PATH = os.environ["B10_FROM_BUILD"] + "/src/bin/recurse"
    AUTH_SPECFILE_PATH = os.environ["B10_FROM_BUILD"] + "/src/bin/auth"
    UNIX_SOCKET_FILE= os.environ["B10_FROM_BUILD"] + "/auth_recurse_conn"
else:
    PREFIX = "@prefix@"
    DATAROOTDIR = "@datarootdir@"
    SPECFILE_PATH = "@datadir@/@PACKAGE@".replace("${datarootdir}", DATAROOTDIR).replace("${prefix}", PREFIX)
    AUTH_SPECFILE_PATH = SPECFILE_PATH
    UNIX_SOCKET_FILE = "@@LOCALSTATEDIR@@/auth_recurse_conn"

SPECFILE_LOCATION = SPECFILE_PATH + "/recurse.spec"
AUTH_SPECFILE_LOCATION = AUTH_SPECFILE_PATH + os.sep + "auth.spec"
MAX_TRANSFERS_OUT = 10
VERBOSE_MODE = False


RESOLVER_MAX_MESSAGE_SIZE = 65535

class ResolverServer:
    def __init__(self):
        self._unix_socket_server = None
        self._log = None
        self._listen_sock_file = UNIX_SOCKET_FILE
        self._shutdown_event = threading.Event()
        self._cc = isc.config.ModuleCCSession(SPECFILE_LOCATION, self.config_handler, self.command_handler)
        self._config_data = self._cc.get_full_config()
        self._cc.start()
        self._cc.add_remote_config(AUTH_SPECFILE_LOCATION);

    def config_handler(self, new_config):
        '''Update config data. TODO. Do error check'''
        answer = create_answer(0)
        for key in new_config:
            if key not in self._config_data:
                answer = create_answer(1, "Unknown config data: " + str(key))
                continue
            self._config_data[key] = new_config[key]

        if self._log:
            self._log.update_config(new_config)

        if self._unix_socket_server:
            self._unix_socket_server.update_config_data(self._config_data)

        return answer


    def shutdown(self):
        '''
            shutdown the recurse process.
        '''

        global recurse_server
        recurse_server = None #Avoid shutdown is called twice
        self._shutdown_event.set()
        if self._unix_socket_server:
            self._unix_socket_server.shutdown()
        sys.exit(0)

    def command_handler(self, cmd, args):
        if cmd == "shutdown":
            self._log.log_message("info", "Received shutdown command.")
            self.shutdown()
            answer = create_answer(0)
        else:
            answer = create_answer(1, "Unknown command:" + str(cmd))

        return answer

    def run(self):
        '''Get and process all commands sent from cfgmgr or other modules. '''
        while not self._shutdown_event.is_set():
            self._cc.check_command(False)


recurse_server = None

def signal_handler(signal, frame):
    if recurse_server:
        recurse_server.shutdown()
        sys.exit(0)

def set_signal_handler():
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)

def set_cmd_options(parser):
    parser.add_option("-a", "--address", dest="address", type="string",
            default="127.0.0.1", help="Address on which recursor listens")
    parser.add_option("-n", "--nocache", dest="nocache", action="store_true",
            help="Specify to disable the cache")
    parser.add_option("-p", "--port", dest="port", type="string",
            default="10", help="UID under which recursor runs")
    parser.add_option("-u", "--uid", dest="uid", type="string",
            default="5301", help="Port on which recursor listens")
    parser.add_option("-v", "--verbose", dest="verbose", action="store_true",
            help="display more about what is going on")

if '__main__' == __name__:
    try:
        parser = OptionParser()
        set_cmd_options(parser)
        (options, args) = parser.parse_args()
        VERBOSE_MODE = options.verbose

        set_signal_handler()
        recurse_server = ResolverServer()
        recurse_server.run()
    except KeyboardInterrupt:
        sys.stderr.write("[b10-recurse] exit recurse process\n")
    except SessionError as e:
        sys.stderr.write("[b10-recurse] Error creating recurse, "
                           "is the command channel daemon running?\n")
    except SessionTimeout as e:
        sys.stderr.write("[b10-recurse] Error creating recurse, "
                           "is the configuration manager running?\n")
    except ModuleCCSessionError as e:
        sys.stderr.write("[b10-recurse] exit recurse process:%s\n" % str(e))

    if recurse_server:
        recurse_server.shutdown()

