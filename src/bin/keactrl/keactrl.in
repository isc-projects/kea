#!/bin/sh

# Copyright (C) 2014 Internet Systems Consortium, Inc. ("ISC")
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
# OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.

# This is keactrl script responsible for starting up Kea processes.
# This script is used to run Kea from installation directory,
# as well as for running tests.

### Logging functions ###

# Logs message at the error level.
log_error() {
    printf "ERROR/keactrl: ${1}\n"
}

# Logs message at the warning level.
log_warning() {
    printf "WARNING/keactrl: ${1}\n"
}

# Logs message at the info level.
log_info() {
    printf "INFO/keactrl: ${1}\n"
}

# Returns a list of existing PIDs and a number of PIDs for the process
# having a name specified as an argument to the function.
get_pids() {
    local proc_name=${1}  # Process name.
    # Return the list of PIDs.
    _get_pids=$(ps axwwo pid,command | grep ${proc_name} | grep -v grep \
        | awk '{print $1}')
    # Return the number of PIDs.
    _get_pids_num=$(printf "%s" "${pids}" | wc -w | awk '{print $1}')
}

# Checks if the specified process is running. Internally it calls get_pids
# to get the number of processes.
check_running() {
    local proc_name=${1} # Process name.
    # Initially mark the process as not running.
    _running=0
    get_pids ${proc_name}
    # If the number of pids is non-zero, the process is running.
    if [ ${_get_pids_num} -gt 0 ]; then
        _running=1
    fi
}

# Sends a signal to a group of processes having a specified name.
send_signal() {
    local sig=${1}        # Signal number
    local proc_name=${2}  # Process name.
    # Get all PIDs for the specified process name.
    get_pids ${proc_name}
    # If no processes running, there is no process we can send the signal
    # to. This is not neccessarily an error.
    if [ -z get_pids ]; then
        log_info "Skip sending signal ${sig} to process ${proc_name}: \
process is not running\n"
        return
    fi
    # Send a signal to all processes.
    kill -${sig} ${_get_pids} >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        log_error "Failed to send signal ${sig} to process ${proc_name}.\n"
    fi
}

# Start the Kea process. Do not start the process if there is an instance
# already running.
start_server() {
    binary_path=${1}  # Full path to the binary.
    binary_args=${2}  # Arguments.
    # Extract the name of the binary from the path.
    local binary_name=$(basename ${binary_path})
    # Use the binary name to check if the process is already running.
    check_running $(basename ${binary_name})
    # If process is running, don't start another one. Just log a message.
    if [ ${_running} -ne 0 ]; then
        log_info "Skip starting ${binary_name} \
as another instance is already running."
    else
        log_info "Starting ${binary_name} ${args}"
        # Start the process.
        ${binary_path} ${args} &
    fi
}

command=
if [ $# -ne 1 ]; then
    log_error "No command specified. Use: start, stop, commit."
    exit 1

elif [ "${1}" != "start" -a "${1}" != "stop" -a "${1}" != "commit" ]; then
    log_error "Illegal command: ${1}"
    exit 1

else
    command=${1}
fi

# Set locations of the Kea binaries. The location depends on whether we
# are running unit tests or we're running the installed binaries.
dhcpv4_srv=
dhcpv6_srv=
dhcp_ddns=
keactrl_conf=

# The environment variable is set when the script is ran from the
# tests. If not set, the Kea installation directory is used.
if test -n "${KEACTRL_BUILD_DIR}"; then
    dhcpv4_srv=${KEACTRL_BUILD_DIR}/src/bin/dhcp4/b10-dhcp4
    dhcpv6_srv=${KEACTRL_BUILD_DIR}/src/bin/dhcp6/b10-dhcp6
    dhcp_ddns=${KEACTRL_BUILD_DIR}/src/bin/d2/b10-dhcp-ddns
else
    prefix=@prefix@
    exec_prefix=@exec_prefix@
    dhcpv4_srv=@libexecdir@/@PACKAGE@/dhcp4/b10-dhcp4
    dhcpv6_srv=@libexecdir@/@PACKAGE@/dhcp6/b10-dhcp6
    dhcp_ddns=@libexecdir@/@PACKAGE@/b10-dhcp-ddns
    keactrl_conf=@etcdir@/@PACKAGE@/keactrl.conf
fi

# KEACTRL_CONF environment variable may hold a location of the keactrl
# configuration file. If this is the case, it overrides the default
# location.
if test -n "${KEACTRL_CONF}"; then
    keactrl_conf=${KEACTRL_CONF}
fi

# Check if the file exists. If it doesn't, it is a fatal error.
if [ ! -f ${keactrl_conf} ]; then
    log_error "keactrl configuration file doesn't exist."
    exit 1
fi

# Include the configuration file.
. ${keactrl_conf}

# Check if the Kea configuration file location has been specified in the
# keactrl configuration file. If not, it is a fatal error.
if [ -z ${kea_config_file} ]; then
    log_error "Configuration file for Kea not specified."
    exit 1
fi

# kea4 and kea6 (=yes) indicate if we should start DHCPv4 and DHCPv6 server
# respectively.
kea4=$( printf "%s" ${kea4} | tr [:upper:] [:lower:] )
kea6=$( printf "%s" ${kea6} | tr [:upper:] [:lower:] )

case ${command} in
    # Start the servers.
    start)
        args="-c ${kea_config_file}"

        if [ ${kea4} == "yes" ]; then
            start_server ${dhcpv4_srv} "${args}"
        fi

        if [ ${kea6} == "yes" ]; then
            start_server ${dhcpv6_srv} "${args}"
        fi

        exit 0 ;;

    # Stop running servers.
    stop)
        send_signal 15 $(basename ${dhcpv4_srv})
        send_signal 15 $(basename ${dhcpv6_srv})

        exit 0 ;;

    # Reconfigure the servers.
    commit)
        send_signal 1 $(basename ${dhcpv4_srv})
        send_signal 1 $(basename ${dhcpv6_srv})

        exit 0 ;;

    # No other commands are supported.
    *)
        log_error "Invalid command:  ${command}."
        exit 1 ;;
esac
fi
