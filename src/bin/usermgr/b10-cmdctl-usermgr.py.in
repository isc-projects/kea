#!@PYTHON@

# Copyright (C) 2010  Internet Systems Consortium.
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SYSTEMS CONSORTIUM
# DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
# INTERNET SYSTEMS CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
# FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
# WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
This file implements user management program. The user name and
its password is appended to csv file.
'''
from bind10_config import SYSCONFPATH
import random
from hashlib import sha1
import csv
import getpass
from optparse import OptionParser, OptionValueError
import os
import sys; sys.path.append ('@@PYTHONPATH@@')
import isc.util.process

isc.util.process.rename()

VERSION_STRING = 'b10-cmdctl-usermgr @PACKAGE_VERSION@'
DEFAULT_FILE = SYSCONFPATH + '/cmdctl-accounts.csv'

class UserManager:
    def __init__(self, options):
        self.options = options

    def print(self, msg):
        if not self.options.quiet:
            print(msg)

    def gen_password_hash(self, password):
        salt = "".join(chr(random.randint(33, 127)) for x in range(64))
        saltedpwd = sha1((password + salt).encode()).hexdigest()
        return salt, saltedpwd

    def username_exists(self, name):
        if not os.path.exists(self.options.output_file):
            return False

        exist = False
        csvfile = None
        with open(self.options.output_file) as csvfile:
            reader = csv.reader(csvfile)
            for row in reader:
                if name == row[0]:
                    exist = True
                    break
        return exist

    def save_userinfo(self, username, pw, salt, filename):
        csvfile = open(filename, 'a')
        writer = csv.writer(csvfile)
        writer.writerow([username, pw, salt])
        csvfile.close()
        self.print("User added\n")

    def add_user(self, name, password):
        """
        Add the given username/password combination to the file.
        First checks if the username exists, and returns False if so.
        If not, it is added, and this method returns True.
        """
        if self.username_exists(name):
            return False
        salt, pw = self.gen_password_hash(password)
        self.save_userinfo(name, pw, salt, self.options.output_file)
        return True

    def interactive_mode(self):
        while True :
            name = input("Username to add: ")
            if name == '':
                print("error, username can't be empty")
                continue

            if self.username_exists(name):
                 print("user already exists!")
                 continue

            while True:
                pwd1 = getpass.getpass("Choose a password: ")
                pwd2 = getpass.getpass("Re-enter password: ")
                if pwd1 != pwd2:
                    print("passwords do not match, try again")
                else:
                    break;

            if not self.add_user(name, pwd1):
                self.print("Error: username exists")

            inputdata = input('Add another user (y/n)? ')
            if inputdata not in ['y', 'Y']:
                break

    def run(self):
        self.print("Using accounts file: " + self.options.output_file)
        filename = self.options.output_file

        if self.options.username is not None or\
           self.options.password is not None:
            if self.options.username is None:
                self.print("Error: password but no username given")
                return 1
            if self.options.password is None:
                self.print("Error: username but no password given")
                return 1
            if not self.add_user(self.options.username,
                                 self.options.password):
                self.print("Error: username exists")
        else:
            try:
                self.interactive_mode()
            except KeyboardInterrupt:
                pass
        return 0

def set_options(parser):
    parser.add_option("-f", "--file",
                      dest="output_file", default=DEFAULT_FILE,
                      help="Specify the file to append user name and password"
                     )
    parser.add_option("-u", "--username",
                      dest="username", default=None,
                      help="Specify username to add"
                     )
    parser.add_option("-p", "--password",
                      dest="password", default=None,
                      help="Specify password to add"
                     )
    parser.add_option("-q", "--quiet",
                      dest="quiet", action="store_true", default=False,
                      help="Quiet mode, don't print any output"
                     )

def main():
    parser = OptionParser(version = VERSION_STRING)
    set_options(parser)
    (options, _) = parser.parse_args()

    usermgr = UserManager(options)
    return usermgr.run()


if __name__ == '__main__':
    result = main()
    sys.exit(result)

